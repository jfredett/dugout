# Premise

Define a DSL for defining a math syntax-tree + parser elements, use that to
maintain / add new operations for doing stuff with. Essentially a meta-language

Ideally this will make it easy to implement the method-missing-based expression
parser. Having each DSL element declaratively state "this is the operation to
look for", "this is the arity it should have", etc should make it relatively
automatable to generate these guys. The Derived/Primitive op stuff is also nice
self-documentation. Makes everything more declarative (albeit at the cost of a
bit more transformational stuff and some potential performance stuff, though I'm
skeptical the perf will suffer, really)

# Status

* Derivative operator needs to be defined
* Simplificator needs to interpret derivative operator appropriately (ie, expand
  out the derivative)

# Simplificator

I'll need a couple things for the simplificator.

* An Expander
* A Simplifier
* A Metric of 'tension'

The algorithm is simple, start with an expansion phase. Until the equation `e`'s
'tension' stops increasing by some threshold (or some hard limit of iterations
is reached), continually apply the 'expansion' algorithm. Then apply the
simplification algorithm in the same fashion, noting the lowest point the
tension reaches. Reduce the hard upper limit by half, repeat the whole process
until the difference in minimum tensions changes by less than some threshold, or
the hard limit of iterations is reached.

## Expander and Simplifier Rules

These could be stored in the DSL as well. Essentially a Rule is simply a
transformation from one state to another, plus a notion of whether it will
increase tension (ie, expand) or decrease it. It might look like:

    rule "Collapse Constant Addition" do
      type :simplification

      match do
        any(Literal) + any(Literal) # any, with an argument or arguments, means
                                    # 'anything which is one of these classes'
      end

      output do |x,y| #block arity must match how many `any` calls were made.
        Literal(x.value + y.value)
      end
    end

    rule "Zero Product Property" do
      type :simplification

      # multiple schemas = multiple match clauses
      match do
        Literal(0) * any #any, with no arguments, means anything
      end

      match do
        any * Literal(0)
      end

      # parameters are optional in the output block
      output do
        Literal(0)
      end
    end

    rule "Exponent Demotion" do
      type :expansion

      match do
        any ** any(Literal)
      end

      output do |xpr, k|
        [xpr].cycle.take(k.value).inject(:*)
      end
    end

Would require an 'Any' construct in the main DSL, but ultimately it neatly
decouples visitation phases, the visitor would simply iterate through each rule,
check to see if the current part of the tree matches any of the match clauses,
apply the output block function, and blammo, simplificated/expanderated

You might also note if any of those rules are idempotent, those rules would
never need to be run twice in a row, in that case.

## Alternative Algorithmic approaches

You might opt for a greedy approach, or greedy-with-lookahead. Most of the time
that will find a good optima. Basically look through available transformations,
see which one reduces the tension the most, and apply it. In the case of
lookahead, with `k` lookahead look for combinations of `k` expanders and
simiplifiers that reduce overall tension the most.

You might even keep a cache of 'good' simplification functions you check first,
and if any give you a good reduction, never bother to check the field (which for
reasonably `k` would get large -- `O(|S|^k)` large -- where `|S|` is the number
of simplifier/expanders you have.

---------

# Implementation details

First we need a `define_pattern` definer as well as a `define_equation` definer.
The former allows you to use the `any` construct, which is a wildcard with some
type constraint ability.

We then define `=~` on the AST classes that compare a pattern w/ the ast and
check to see if it matches. It should return a list of the ASTs which match, or
nil if none do.

Now we need to be able to replace those ASTs with the output that is
simpler/more complicate (depending on the particular rewrite rule that is
defined).

This gets a bit tricky, really we need to know the parent, and replace the
particular attribute with the simpler version. Since the match clauses in the
rewrite rules are written from the perspective of the thing-to-be-simplified,
and not the parent, we need to either doubly-link the list, or we need to alter
`=~` to provide us the context.

To get around this, we can instead do the following, described recursively, and
indeed no AST should be so deep that it would blow the stack, so it could
probably be implemented recursively too.


    def visit(ast)
      matchers.each do |matcher|
        return visit(matcher.output_for(ast)) if ast =~ matcher
      end
      return ast.class.new(*ast.leaves.map { |leaf| visit(leaf) })
    end

The final return could be written to not re-allocate if performance dictates,
and indeed this could be shoved into the class definition for each operation.

We can also potentially optimize by classifying simplifications by their primary
function. So that instead of iterating over every matcher, we iterate over each
one that matches the class of the ast we're iterating on.

Note that the we visit the output of the matcher. Certain high-level re-write
rules might move chunks of the tree around without fully simplifying the
subtree, this ensures we simplify the whole subtree on each pass.

As noted above, we may need to iterate this many times to get the simplest
equation.

Another important fact is that sometimes we match against _specific instances_
of classes. Like when we match `lit(0) * any`. Essentially `=~` is a weakened
`==` where it acts as a normal `==`, but with the following caveats:


1. `any(klasses)` matches any instance of the specified classes.
2. variables match even if their names don't match, so long as they match
   consistently. That is, `x * y` should match `a * b`, whereas it clearly
   doesn't equal each other. But `x * y` should _not_ match `a * a`, because
   it is implied that `x /= y`.

